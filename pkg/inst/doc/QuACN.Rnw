%\VignetteIndexEntry{QuACN}
\documentclass[a4paper]{article}
\usepackage{hyperref} 
\usepackage[hmargin=.75in,vmargin=1in]{geometry}
\usepackage[american]{babel}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{caption}
\usepackage{textcomp}
\usepackage{epsfig,graphicx}
\usepackage{xcolor}
\usepackage{amsfonts,amsmath,amssymb}
\usepackage{fixltx2e} % Fixing numbering problem when using figure/table* 
\usepackage{booktabs}

\title{\texttt{\textbf{QuACN}}: \textbf{Qu}antitative \textbf{A}nalyze of \textbf{C}omplex \textbf{N}etworks}
\author{Laurin AJ Mueller, Karl G Kugler, Matthias Dehmer}
\begin{document}
\maketitle
\tableofcontents
\section{Overview}
For information about the actual build see the projects website:

\begin{itemize}
 \item R-Forge: \url{http://quacn.r-forge.r-project.org/}
 \item CRAN: \url{http://cran.r-project.org/web/packages/QuACN/}
\end{itemize}

This vignette provides an overview about the usage of \texttt{QuACN}. 

Chapter \ref{sec:nw} will give you an idea how to import already exiting networks. In Chapter \ref{sec:desc} a brief description of the implemented measures is presented, and it demonstrates how to call the related method in R.

\subsection{Installation}
\texttt{QuACN} uses the packages \texttt{graph} and \texttt{RBGL} from the \textit{Bioconductor} project. Before installing \texttt{QuACN}, \textit{Bioconductor} with the corresponding packages needs to be installed. For instructions see the \textit{Bioconductor} website:

\begin{itemize}
 \item Bioconductor: \url{http://www.bioconductor.org/}
\end{itemize}

Note, that \texttt{QuACN} also depends on the \texttt{Rmpfr} package. Therefore, the software GMP (\url{http://gmplib.org/}) and MPFR ( \url{http://www.mpfr.org/}) needs to be installed to install the package correctly:

\begin{itemize}
 \item Windows: The package should install without problems.
 \item Ubuntu/Debian: Make sure that the libraries \textit{libgmp3-dev} and \textit{libmpfr-dev} are installed.
\end{itemize}
For more information see the corresponding websites, or the documentation of the \texttt{Rmpfr} package (\url{http://rmpfr.r-forge.r-project.org/}).

After installing \textit{GMP} and \textit{MPFR} everything is ready to install \texttt{QuACN}. Other dependencies will be installed automatically during the installation. To install the package from \textit{CRAN} simply type: 

<<echo=TRUE, eval=FALSE>>=
install.packages("QuACN")
@
\section{Networks}
\label{sec:nw}
This section shows how to create networks in R to use them with \texttt{QuACN}.

\subsection{graphNEL}
<<echo=FALSE>>=
library("graph")
library("RBGL")
@ 
We generate a random graph with 8 nodes.  This graph will be used to explain the implemented methods. To analyze a network the network has to be represented by a \textit{graphNEL}-object, which is part of the Bioconductor \texttt{graph} package.\\

<<label=randGraph,include=FALSE>>=
library("QuACN")
set.seed(666)
g <- randomGraph(1:8, 1:5, 0.36)
g
@ 

\subsection{Adjacency Matrix}
<<echo=FALSE>>=
A <- adjacencyMatrix(g)
@ 

To create a \textit{graphNEL} object from an adjacency matrix $A$, just type following command:

<<label=randGraph,include=FALSE>>=
A
g <- as(A,"graphNEL")
g
@

If you have already created networks that you want to analyze with \texttt{QuACN}, R offers several ways to import them. (It is important to know that networks have to be represented by \textit{graphNEL}-objects.) Note that there is no general procedure to get your networks into an R-workspace. Some possibilities to import network data are listed below:

\begin{itemize}
\item \textbf{Adjacency matrix}: A representation of your network as an adjacency matrix can be easily imported and converted into a \textit{graphNEL} object.
\item \textbf{Node- and Edge-List}: With a list of nodes and Edges it is easy to create a \textit{graphNEL}-object.
\item \textbf{read.graph()}: The \texttt{read.graph()} method of the \textit{graph}-package offers the possibility to import graphs that a represented in different formats. For details see the manual of the \textit{graph}-package.
\item \textbf{System Biology Markup Language(SBML) \cite{Hucka2003}}: With the \textit{RSBML}-package it is possible to import SBML-Models.
\item \textbf{igrah-package}: Networks created with the \textit{igraph}-package can be converted into graphNEL objects.
\end{itemize}

\subsection{Extract the Largest Connected Subgraph}
Many of the topological network descriptors that are implemented in \texttt{QuACN} only work on connected graphs. Often this is not the case with biological networks, so that the largest connected component (LCC) has to be extracted first. For extracting the LCC we provide the method \texttt{getLargestSubgraph(g)}, as shown in \cite{Hahne2008}:
<<>>=
g2 <- randomGraph(paste("A",1:100, sep=""), 1:4, p=0.03)
lcc <- getLargestSubgraph(g2)
lcc
@

\subsection{Enumerate Edge-Deleted Subgraphs}

Some descriptors require a list of all distinct subgraphs which can be
generated from a graph by removing a single or two edges.  The
concerning methods will obtain this information automatically, but for
efficiency reasons, you might want to pre-calculate and reuse it:

<<>>=
sg.1ed <- edgeDeletedSubgraphs(g)
sg.2ed <- edgeDeletedSubgraphs(sg.1ed)
@

Note that the method \texttt{edgeDeletedSubgraphs(g)} accepts lists or
single instances of graphNEL objects or adjacency matrices, but it
always returns a list of adjacency matrices.

\section{Network Descriptors}
\label{sec:desc}
This section provides a overview of the network descriptors that are included in the \texttt{QuACN} package. Here we describe the respective descriptor and how to call it in R.\\

Note that every descriptor has at least two parameters, the \textit{graphNEL}-object and the distance matrix representing the network. It is not necessary to pass the distance matrix to a function. If the parameters stays empty or is set to \textit{NULL} the distance matrix will be estimated within each function. But if you want to calculate more than one descriptor, it is recommended to calculate the distance matrix separately and pass it to each method. Some of the methods need the degree of each node or the adjacency matrix to calculate their results. If they were calculated once they should have kept for later use. Specially with large networks it saves a lot of time, not to calculate these parameters for each descriptor again, and will enhance the performance of your script.
<<>>=
mat.adj <- adjacencyMatrix(g)
mat.dist <- distanceMatrix(g)
vec.degree <- graph::degree(g)
ska.dia <- diameter(g)
ska.dia <- diameter(g,mat.dist)
@ 
\subsection{Descriptors Based on Distances in a Graph} \label{sec:dist}
This section describes network measures based on distances in the network.
\subsubsection*{ Wiener Index \cite{Wiener1947}:}
\begin{equation}
W(G):= \frac{1}{2} \sum_{i=1}^{|N|}\sum_{j=1}^{|N|}d(v_i,v_j).
\end{equation}
where $|N(G)|:=|N|$ denotes the number of Nodes of the complex network.
$d(v_i,v_j)$ stands for shortest distances between $v_i,v_j \in V$.

<<>>=
wien <- wiener(g)
wiener(g,mat.dist)
@ 

\subsubsection*{Hararay Index \cite{balaban_ivanciuc_2000}:}
\begin{equation}
H(G):= \frac{1}{2} \sum_{i=1}^{|N|}\sum_{j=1}^{|N|}(d(v_i,v_j))^{-1}, \quad i \ne j.
\end{equation}
<<>>=
harary(g)
harary(g,mat.dist)
@ 
\subsubsection*{Balaban J Index \cite{balaban_1982}:}
\begin{equation}
J(G):= \frac{|E|}{\mu + 1} \sum_{(v_i,v_j) \in E} [DS{_i}DS{_j}]^{- \frac{1}{2}},
\end{equation}
<<>>=
balabanJ(g)
balabanJ(g,mat.dist)
@ 
where $|E(G)|:= |E|$ denotes the number of edges of the complex network, $DS_i$ denotes the distance sum (row sum) of $v_i$ and $\mu := |E| + 1 - |N|$ denotes the cyclomatic number.

\subsubsection*{Mean distance deviation \cite{skorobogatov}:}

\begin{equation}
\Delta\mu(G):= \frac{1}{N}\sum_{i=1}^{N}|\mu(v_i)- \bar{\mu}|,
\end{equation}
%
where
%
\begin{equation}\label{dobrynin_eq1}
\mu(v_i):= \sum_{j=1}^{N}d(v_i,v_j),
\end{equation}
%
and
\begin{equation}\label{dobrynin_eq2}
\bar{\mu}:= \frac{2W}{N}.
\end{equation}
<<>>=
meanDistanceDeviation(g)
meanDistanceDeviation(g,mat.dist)
@ 

\subsubsection*{Compactness  \cite{doyle_1977}:}
\begin{equation}
C(G):= \frac{4W}{|N|(|N|-1)}.
\end{equation}
<<>>=
compactness(g)
compactness(g,mat.dist)
compactness(g,mat.dist,wiener(g,mat.dist))
@ 
\subsubsection*{Product of Row Sums index \cite{schultz_1992}:}
\begin{equation}
\text{PRS}(G)= \prod_{i=1}^{|N|} \mu(v_i) \quad \mbox{or} \quad   \log \big(\text{PRS}(G)\big)= \log\left( \prod_{i=1}^{|N|} \mu(v_i) \right).
\end{equation}


<<>>=
productOfRowSums(g,log=FALSE)
productOfRowSums(g,log=TRUE)
productOfRowSums(g,mat.dist,log=FALSE)
productOfRowSums(g,mat.dist,log=TRUE)
@ 
\subsubsection*{Hyper-distance-path index \cite{todeschini_2002}}
\begin{equation}
D_P(G):= \frac{1}{2} \sum_{i=1}^{|N|} \sum_{j=1}^{|N|} d(v_i,v_j) +  \frac{1}{2} \sum_{i=1}^{|N|} \sum_{j=1}^{|N|}  {d(v_i,v_j) \choose 2}.
\end{equation}

<<>>=
hyperDistancePathIndex(g)
hyperDistancePathIndex(g,mat.dist)
hyperDistancePathIndex(g,mat.dist,wiener(g,mat.dist))
@ 

\subsubsection*{Skorobogatov and A. A. Dobrynin \cite{skorobogatov}:}
% TODO
<<>>=
dobrynin(g)
dobrynin(g, mat.dist)
@



\subsection{Descriptors Based on Other Graph-Invariants}
\label{sec:otherInv}
This section describes network measures based on other invariants than distances.


\subsubsection*{Index of total adjacency \cite{bonchev_book_2005}:}
\begin{equation}
A(G):= \frac{1}{2} \sum_{i=1}^{|N|}\sum_{j=1}^{|N|}a_{ij}.
\end{equation}
<<>>=
totalAdjacency(g)
totalAdjacency(g,mat.adj)
@ 

\subsubsection*{Zagreb group indices \cite{diudea}, \cite{nikolic_2003}:}
\begin{equation}
Z_1(G):= \sum_{i=1}^{|N|} k_{v_i},
\end{equation}
where $k_{v_i}$ is the degree of the node $v_i$.
\begin{equation}
Z_2(G):= \sum_{(v_i,v_j) \in E} k_{v_i} k_{v_j}.
\end{equation}
Modified, augmented and variable Zagreb indices:
\begin{eqnarray}
\mathit{MZI} &:=& \sum_{(v_i, v_j) \in E} \frac{1}{k_{v_i} k_{v_j}} \\
\mathit{AZI} &:=& \sum_{(v_i, v_j) \in E} \left( \frac{k_{v_i} k_{v_j}}{k_{v_i} + k_{v_j} - 2} \right)^3\\
\mathit{VZI} &:=& \sum_{(v_i, v_j) \in E} \frac{k_{v_i} + k_{v_j} - 2}{k_{v_i} k_{v_j}}
\end{eqnarray}
<<>>=
zagreb1(g)
zagreb1(g,vec.degree)
zagreb2(g)
zagreb2(g,vec.degree)
modifiedZagreb(g)
modifiedZagreb(g, vec.degree)
augmentedZagreb(g)
augmentedZagreb(g, vec.degree)
variableZagreb(g)
variableZagreb(g, vec.degree)
@ 

\subsubsection*{Randi\'{c} connectivity index \cite{li_gutman_2006}:}
\begin{equation}
R(G):= \sum_{(v_i,v_j) \in E} [k_{v_i} k_{v_j}]^{- \frac{1}{2}}.
\end{equation}
<<>>=
randic(g)
randic(g,vec.degree)
@ 

\subsubsection*{The complexity index B \cite{bonchev_book_2005}:}
\begin{equation}
B(G):= \sum_{i=1}^{|N|} \frac{k_{v_i}}{\mu(v_i)}.
\end{equation}
  

<<>>=
complexityIndexB(g)
complexityIndexB(g,mat.dist)
complexityIndexB(g,mat.dist,vec.degree)
@ 
\subsubsection*{Normalized edge complexity \cite{bonchev_book_2005}:}
\begin{equation}
E_N(G):=\frac{A(G)}{|N|^2}.
\end{equation}
<<>>=
normalizedEdgeComplexity(g)
normalizedEdgeComplexity(g,totalAdjacency(g,mat.adj))
@ 

\subsubsection*{Atom-bond connectivity \cite{estrada_1998}:}
\begin{equation}
\mathit{ABC} := \sum_{(v_i, v_j) \in E} \sqrt{\frac{k_{v_i} + k_{v_j} - 2}{k_{v_i} k_{v_j}}}
\end{equation}
<<>>=
atomBondConnectivity(g)
atomBondConnectivity(g, vec.degree)
@

\subsubsection*{Geometric-arithmetic indices \cite{zhou_2009}:}
\begin{eqnarray}
\mathit{GA1} &:=& \sum_{(v_i, v_j) \in E} \frac{\sqrt{k_{v_i} k_{v_j}}}{\frac{1}{2} (k_{v_i} + k_{v_j})} \\
\mathit{GA2} &:=& \sum_{(v_i, v_j) \in E} \frac{\sqrt{n_i n_j}}{\frac{1}{2} (n_i + n_j)} \\
\mathit{GA3} &:=& \sum_{(v_i, v_j) \in E} \frac{\sqrt{m_i m_j}}{\frac{1}{2} (m_i + m_j)}
\end{eqnarray}
where \(n_i := |\{x \in N : d(x, v_i) < d(x, v_j)\}|\) and \(n_j := |\{x \in N : d(x, v_j) < d(x, v_i)\}|\);
\(m_i := |\{f \in E : d(f, v_i) < d(f, v_j)\}|\) and \(m_j := |\{f \in V : d(f, v_j) < d(f, v_i)\}|\).
In this context, the distance between an edge \(f = \{x, y\}\) and a vertex \(v\) is defined as
\(d(f, v) := \min \{d(x, v), d(y, v)\}\).
<<>>=
geometricArithmetic1(g)
geometricArithmetic1(g, vec.degree)
geometricArithmetic2(g)
geometricArithmetic2(g, mat.dist)
geometricArithmetic3(g)
geometricArithmetic3(g, mat.dist)
@

\subsubsection*{Narumi-Katayama index \cite{narumi_katayama_1984}:}
\begin{equation}
\mathit{NK} := \prod_{i=1}^n k_{v_i}
\end{equation}
<<>>=
narumiKatayama(g)
narumiKatayama(g, vec.degree)
@

\subsection{Classical entropy based descriptors}
\label{sec:clE}
These measures are based on grouping the elements of an arbitrary graph invariant (vertices, edges, and distances etc.) using an equivalence criterion.


\subsubsection*{Topological information content \cite{mowshowitz_1,rashewsky}:}
\begin{equation}\label{eq_mean_information_trucco}
I^V_{orb}(G) := -  \sum_{i=1}^{k} \frac{|N^V_i|}{|N|} \log \left( \frac{|N^V_i|}{|N|} \right).
\end{equation}
%
$|N^V_i|$ denotes the number of vertices belonging to the $i$-th vertex orbit.
<<>>=
topologicalInfoContent(g)
topologicalInfoContent(g,mat.dist)
topologicalInfoContent(g,mat.dist,vec.degree)
@ 

\subsubsection*{Bonchev - Trinajsti\'{c} indices \cite{bonchev_Trinajstic_1977}:}
\begin{equation}
I_D(G) := - \frac{1}{|N|}\log\left( \frac{1}{|N|} \right)- \sum_{i=1}^{\rho(G)} \frac{2k_i}{|N|^2}\log\left( \frac{2k_i}{|N|^2} \right), \label{eq_mean_information_bonchev}
\end{equation}
\begin{equation}
I^W_D(G) := W(G) \log(W(G)) -  \sum_{i=1}^{\rho(G)} i k_i \log(i).
\end{equation}
%
$k_i$ is the occurrence of a distance possessing value $i$ in the distance matrix of $G$.
<<keep.source=TRUE>>=
#I_D(G)
bonchev1(g)
bonchev1(g,mat.dist)
#I^W_D(G)
bonchev2(g)
bonchev2(g,mat.dist)
bonchev2(g,mat.dist,wiener(g))
@
\subsubsection*{BERTZ complexity index \cite{bertz_1981}:}
\begin{equation}\label{eq_total_information_bertz}
C(G):= 2N \log(|N|) - \sum_{i=1}^{k} |N_i| \log \left( |N_i| \right).
\end{equation}
%
$|N_i|$ are the cardinalities of the vertex orbits as defined in Eqn.~(\ref{eq_mean_information_trucco}).

<<>>=
bertz(g)
bertz(g,mat.dist)
bertz(g,mat.dist,vec.degree)
@ 
\subsubsection*{Radial centric information index \cite{bonchev_2}:}
\begin{equation}\label{radial_index}
I_{C,R}(G) := \sum_{i=1}^{k} \frac{|N^e_i|}{|N|} \log \left( \frac{|N^e_i|}{|N|} \right).
\end{equation}
%
$|N^e_i|$ is the number of vertices having the same eccentricity.
<<>>=
radialCentric(g)
radialCentric(g,mat.dist)
@ 
\subsubsection*{Vertex degree equality-based information index \cite{bonchev_2}:}
\begin{equation}
I_{deg}(G) := \sum_{i=1}^{\bar{k}} \frac{|N^{k_v}_i|}{|N|} \log \left( \frac{|N^{k_v}_i|}{|N|} \right).
\end{equation}
%
$|N^{k_v}_i|$ is the number of vertices with degree equal to $i$ and $\bar{k}:= \max_{v\in V}k_v$.
<<>>=
vertexDegree(g)
vertexDegree(g,vec.degree)
@ 
\subsubsection*{Balaban-like information indices \cite{balaban_1991}:}

Note, that this class of Descriptors return \textit{Inf} if you have a graph with $|V| < 3$.

\begin{eqnarray}
U(G):= \frac{|E|}{\mu +1} \sum_{(v_i,v_j) \in E} [u(v_i)u(v_j)]^{- \frac{1}{2}}, \label{eq_balaban_U_index} \\
X(G):= \frac{|E|}{\mu +1} \sum_{(v_i,v_j) \in E} [x(v_i)x(v_j)]^{- \frac{1}{2}}, \label{eq_balaban_X_index}
\end{eqnarray}
%
where
%
\begin{eqnarray}
u(v_i) &:=&  -  \sum_{j=1}^{\sigma(v_i) } \frac{j|S_j(v_i,G)|}{\mu(v_i)} \log\left( \frac{j}{\mu(v_i)} \right), \\
x(v_i) &:=& - \mu(v_i) \log(d(v_i)) - y_i, \\
y_i &:=& \sum_{j=1}^{\sigma(v_i) } j|S_j(v_i,G)| \log(j),\\
\mu(v_i) &:=& \sum_{j=1}^{|N|}d(v_i,v_j) = \sum_{j=1}^{|N|} j|S_j(v_i,G)|.
\end{eqnarray}

<<keep.source=TRUE>>=
#Balaban-like information index U(G)
balabanlike1(g)
balabanlike1(g,mat.dist)
#Balaban-like information index X(G)
balabanlike2(g)
balabanlike2(g,mat.dist)
@

\subsubsection*{Graph vertex complexity index \cite{raychaudhury_1984}:}
\begin{equation}
I_V(G):= \sum_{i=1}^{N}v^c_i,
\end{equation}
where $v^c_i$ is the so-called vertex complexity expressed by
\begin{equation}
v^c_i:= \sum_{j=0}^{\sigma(v_i)} \frac{k^{v_i}_j}{N} \log \left( \frac{k^{v_i}_j}{N} \right).
\end{equation}
$k^{v_i}_k$ is the number of distances starting from $V_i \in V$ equal to $j$.
<<>>=
graphVertexComplexity(g)
graphVertexComplexity(g,mat.dist)
@ 

\subsubsection*{Offdiagonal complexity \cite{kim_wilhelm_2008}:}
\begin{equation}
\mathit{OdC} := - \frac{1}{log(|N|-1)}
  \sum_{n=0}^{k_{\mathrm{max}}-1} \tilde{a}_n \log \tilde{a}_n
\end{equation}
with \(\tilde{a}_n = \frac{a_n}{\sum_{m=0}^{k_{\mathrm{max}}-1} a_m}\)
and \(a_n = \sum_{i=1}^{k_{\mathrm{max}-|N|}} c_{i,i+|N|}\), where
\(k_{\mathrm{max}}\) is the maximum degree of all nodes in the graph,
and \(c_{ij}\) is the number of all neighbors with degree \(j \ge i\) of
all nodes with degree \(i\).
<<>>=
offdiagonal(g)
offdiagonal(g, vec.degree)
@

\subsubsection*{Spanning tree sensitivity \cite{kim_wilhelm_2008}:}
\begin{equation}
\mathit{STS} := \frac{-\sum_l a_l \log a_l}{\log m_{\mathit{cu}}}
\end{equation}
with \(m_{\mathit{cu}} = n^{1.68}-10\), \(a_l = \frac{S_{ij}^l}{\sum_r^k
S_{ij}^r}\), \(S_{ij} = s_{ij}
- (\min\{s_{ij}\} - 1)\) and \(\{S_{ij}^1, S_{ij}^2, \ldots,
S_{ij}^k\}\) being an ordered list of all \(k\) different \(S_{ij}\).
\(s_{ij}\) is the number of spanning trees in the graph minus the number
of spanning trees of the subgraph with the edge \(\{v_i, v_j\}\)
deleted.  Analogously, the spanning tree sensitivity differences measure
is defined as
\begin{equation}
\mathit{STSD} := \frac{-\sum_l b_l \log b_l}{\log m_{\mathit{cu}}}
\end{equation}
with \(b_l = \frac{\mathit{Ld}_l}{\sum_r^d \mathit{Ld}_r}\), where
\(\{\mathit{Ld}_1, \mathit{Ld}_2, \ldots, \mathit{Ld}_d\}\) is the
ordered list of all unique differences \(S_{ij}^m - S_{ij}^{m-1}\).
<<>>=
spanningTreeSensitivity(g)
spanningTreeSensitivity(g, sg.1ed)
@

\subsubsection*{Distance degree/code centric indices \cite{todeschini_2002}:}
\begin{eqnarray}
I_{\mathrm{C,deg}} &:=& -\sum_{i=1}^D \frac{d_i}{|N|} \log_2 \frac{d_i}{|N|} \\
I_{\mathrm{C,code}} &:=& -\sum_{i=1}^C \frac{c_i}{|N|} \log_2 \frac{c_i}{|N|}
\end{eqnarray}
where \(d_i\) is the number of vertices with the same eccentricity and
the same vertex distance degree (i.\,e., equal row sums in the distance
matrix), and \(c_i\) is the number of vertices with the same vertex
distance code (i.\,e., the same numbers in their rows in the distance
matrix).  \(D\) and \(C\) are the respective numbers of equivalence
classes.
<<>>=
distanceDegreeCentric(g)
distanceDegreeCentric(g, mat.dist)
distanceCodeCentric(g)
distanceCodeCentric(g, mat.dist)
@

\subsection{Parametric Graph Entropy Measures}
\label{sec:dE}
Measures of this group \cite{dehmer_functionals_2008,dehmer_varmuza_2009} assign a probability value to each vertex of the network using a so-called information functional $f$
which captures structural information of the network $G$. We yield \cite{dehmer_functionals_2008},
\begin{equation}\label{eq:if}
I_{f}(G):=-\sum_{i=1}^{|N|}{\frac{f(v_i)}{\sum_{j=1}^{|N|}f(v_j)} \log\left(\frac{f(v_i)}{\sum_{j=1}^{|N|}f(v_j)}\right)},
\end{equation}
%
where $I_{f}(G)$ represents a family of graph entropy \cite{dehmer_functionals_2008} measures depending on the information functional.
Further we implemented the following measurement\cite{dehmer_varmuza_2009}:
\begin{equation}\label{eq:dist}
I^{\lambda}_{f}(G) := \lambda \left( \log(|N|) + \sum_{i=1}^{|N|}{p(v_i)\log(p(v_i))} \right),
\end{equation}
\begin{equation}\label{eq:pis}
p(v_i):={\frac{f(v_i)}{\sum_{j=1}^{|N|}f(v_j)}},
\end{equation}
where $p^V(v_i)$ are the vertex probabilities, $\lambda > 0$ a scaling constant. This measure can be interpreted as the distance between the entropy defined in equation \ref{eq:if} and maximum entropy ($\log(|N|)$).

We integrated 4 different information functionals:

\begin{enumerate}
\item An information functional using the j-spheres (\textit{"sphere"}):
\begin{equation}
\label{eq:spherfunct}
f^{V}(v_i):= c_1|S_1(v_i,G)| + c_2|S_2(v_i,G)| + \cdots + c_{\rho(G)}|S_{\rho(G)}(v_i,G)|,
\end{equation}
where $ c_k > 0$.

\item An information functional using path lengths (\textit{"pathlength"}):
\begin{equation}
  f^{P}(v_i) := c_1l(P(L_G(v_i,1))) + c_2l(P(L_G(v_i,2))) + \cdots + c_{\rho(G)}l(P(L_G(v_i,\rho(G)))),
\end{equation}
where $ c_k > 0$.
\item An information functional using vertex centrality(\textit{"vertcent"}) :
\begin{equation} 
  f^{C}(v_i) := c_1\beta^{L_G(v_i,1)}(v_i) + c_2\beta^{L_G(v_i,2)}(v_i) + \cdots + c_{\rho(G)}\beta^{L_G(v_i,\rho(G))}(v_i),
\end{equation}
where $ c_k > 0$.
\item Calculates the degree degree association index(\textit{"degree"}) \cite{dehmer_hindawi_2010}:
\begin{equation} 
  f^{\Delta}(v_i) := \alpha^{c_1 \Delta^G(v_i,1) + c_2 \Delta^G(v_i,2) + \cdots + c_{\rho(G)} \Delta^G(v_i,{\rho(G)})},
\end{equation}
where $ c_k > 0$, $1 \leq k \leq \rho(G)$ and $\alpha>0$ 
\end{enumerate}



We implemented 4 different settings (as example settings) of the weighting parameter $c_i$:

\begin{enumerate}
\item constant
\begin{equation}
\label{eq:const}
c_1:= 1,\, c_2:=  1, \cdots, \, c_{\rho(G)}:= 1.
\end{equation}

\item linear
\begin{equation}
\label{eq:lin}
c_1:= \rho(G),\, c_2:= \rho(G)-1, \cdots, \, c_{\rho(G)}:= 1.
\end{equation}

\item quadratic
\begin{equation}
\label{eq:exp}
c_{1}:= \rho(G)^2, c_{2}:= (\rho(G)-1)^2, \cdots, c_{\rho(G)}:= 1.
\end{equation}
\item exponential
\begin{equation}
\label{eq:exp}
c_{1}:= \rho(G), c_{2}:= \rho(G)e^{1}, \cdots, c_{\rho(G)}:= \rho(G)e^{-\rho(G) + 1}.
\end{equation}
$\rho(G)$ represents the diameter of the network.

\end{enumerate}

To call this type of network measure we provide the method \textit{infoTheoreticGCM}. 
It has following input parameters:
\begin{itemize}
\item \textit{g}: the network as a graphNEL object - it is the only mandatory parameter
\item \textit{dist}: the distance matrix of g
\item \textup{coeff}: specifies the weighting parameter: "const", "lin", "quad", "exp", "const" or "cust" are available constants. If it is set to
    "cust" you have to specify your customized weighting schema with the parameter \textit{custCoeff}.
\item \textit{infofunct}: specifies the information functional: "sphere", "pathlength", "vertcent" or "degree" are available settings.
\item \textit{lambda}: scaling constant for the distance, default set to 1000.
\item \textit{custCoeff}: specifies the customized weighting schema. To use it you need to set \textit{coeff}="const".
\end{itemize}

Note that some combinations of these settings can cause the descriptor to return \textit{NaN}. In that case you have to check for \textit{warnings}.

The method returns a list with following entries:
\begin{itemize}
\item \textit{entropy}: contains the entropy, see formula \ref{eq:if} 
\item \textit{distance}: contains the distance described in formula \ref{eq:dist}
\item \textit{pis}: contains the probability distribution, see formula \ref{eq:pis}
\item \textit{fvi}: contains the values of the used information functional for each vertex $v_i$
\end{itemize}


<<>>=
l1 <- infoTheoreticGCM(g)
l2 <- infoTheoreticGCM(g,mat.dist,coeff="lin",infofunct="sphere",lambda=1000)
l3 <- infoTheoreticGCM(g,mat.dist,coeff="const",infofunct="pathlength",lambda=4000)
l4 <- infoTheoreticGCM(g,mat.dist,coeff="quad",infofunct="vertcent",lambda=1000)
l5 <- infoTheoreticGCM(g,mat.dist,coeff="exp",infofunct="degree",lambda=1000)
l1
l5
@ 

\subsection{Eigenvalue-based Descriptors}

This class contains Eigenvalue-based Descriptors proposed in Dehmer et. al \cite{dehmer_degree_2010}. 

\begin{equation}
H_{M_s(G)}=\sum_{i=1}^k \frac{|\lambda_i|^{\frac{1}{s}}}{\sum_{j=1}^k |\lambda_j|^{\frac{1}{s}}} \log \left( \frac{|\lambda_i|^{\frac{1}{s}}}{\sum_{j=1}^k |\lambda_j|^{\frac{1}{s}}} \right),
\end{equation}

\begin{equation}
S_{M_s(G)}= |\lambda_1|^{\frac{1}{s}} + |\lambda_2|^{\frac{1}{s}} + \ldots + |\lambda_k|^{\frac{1}{s}},
\end{equation}

\begin{equation}
IS_{M_s(G)}= \frac{1}{|\lambda_1|^{\frac{1}{s}} + |\lambda_2|^{\frac{1}{s}} + \ldots + |\lambda_k|^{\frac{1}{s}}},
\end{equation}

\begin{equation}
P_{M_s(G)}=|\lambda_1|^{\frac{1}{s}} \cdot |\lambda_2|^{\frac{1}{s}}  \ldots  |\lambda_k|^{\frac{1}{s}},
\end{equation}

\begin{equation}
IP_{M_s(G)}= \frac{1}{|\lambda_1|^{\frac{1}{s}} \cdot |\lambda_2|^{\frac{1}{s}}  \ldots  |\lambda_k|^{\frac{1}{s}}},
\end{equation}

With this function it is possible to calculate 5 descriptors ($H_{M_s(G)}$, $S_{M_s(G)}$ , $IS_{M_s(G)}$, $P_{M_s(G)}$, $IP_{M_s(G)}$) for 10 different matrices:

\begin{enumerate}
\item Adjacency matrix
<<>>=
eigenvalueBased(g,adjacencyMatrix,2)
@ 
\item Laplacian matrix
<<>>=
eigenvalueBased(g,laplaceMatrix,2)
@
\item Distance matrix
<<>>=
eigenvalueBased(g,distanceMatrix,2)
@
\item Distance path Matrix
<<>>=
eigenvalueBased(g,distancePathMatrix,2)
@
\item Augmented vertex degree matrix
<<>>=
eigenvalueBased(g,augmentedMatrix,2)
@
\item Extended adjacency matrix
<<>>=
eigenvalueBased(g,extendedAdjacencyMatrix,2)
@
\item Vertex Connectivity matrix 
<<>>=
eigenvalueBased(g,vertConnectMatrix,2) 
@
\item Random Walk Markov matrix 
<<>>=
eigenvalueBased(g,randomWalkMatrix,2)  
@
\item Weighted structure function matrix $IM_1$
<<>>=
eigenvalueBased(g,weightStrucFuncMatrix_lin,2) 
@
\item Weighted structure function matrix $IM_2$
<<>>=
eigenvalueBased(g,weightStrucFuncMatrix_exp,2)
@
\end{enumerate}

For a detailed description of this class see Dehmer et. al \cite{dehmer_degree_2010}.

\subsubsection*{Graph energy and Laplacian energy \cite{gutman_zhou_2006}:}
\begin{eqnarray}
E &:=& \sum_{i=1}^{|N|} |\lambda_i| \\
\mathit{LE} &:=& \sum_{i=1}^{|N|} \left| \mu_i - \frac{2m}{n} \right|
\end{eqnarray}
where \(\lambda_k\) are the eigenvalues of the adjacency matrix and \(\mu_k\) those of the Laplacian matrix of the graph.
<<>>=
energy(g)
laplacianEnergy(g)
@

\subsubsection*{Estrada \cite{estrada_2000} and Laplacian Estrada \cite{fath-tabar_2009} indices:}
\begin{eqnarray}
\mathit{EE} &:=& \sum_{i=1}^{|N|} e^{\lambda_i} \\
\mathit{LEE} &:=& \sum_{i=1}^{|N|} e^{\mu_i}
\end{eqnarray}
with \(\lambda_k\) and \(\mu_k\) defined as above.
<<>>=
estrada(g)
laplacianEstrada(g)
@

\subsubsection*{Spectral radius:}
\begin{equation}
\mathit{SpRad} := \max_i \left\{|\lambda_i|\right\}
\end{equation}
<<>>=
spectralRadius(g)
@

\subsection{Different subgraph measures}

\subsubsection*{One-edge-deleted subgraph complexity \cite{kim_wilhelm_2008}:}
\begin{eqnarray}
C_{\mathit{1e,ST}} &:=& \frac{N_{\mathit{1e,ST}} - 1}{m_{\mathit{cu}}-1} \\
C_{\mathit{1e,Spec}} &:=& \frac{N_{\mathit{1e,Spec}} - 1}{m_{\mathit{cu}} - 1}
\end{eqnarray}
\(N_{\mathit{1e,ST}}\) is the number of one-edge-deleted subgraphs which
are different with regard to the number of spanning trees.  Similarly,
\(N_{\mathit{1e,Spec}}\) is the number of one-edge-deleted subgraphs
which are different with regard to spectra of the Laplacian and signless
Laplacian matrix.  \(m_\mathit{cu}\) is defined as \(n^{1.68}-10\).
<<>>=
oneEdgeDeletedSubgraphComplexity(g)
oneEdgeDeletedSubgraphComplexity(g, sg.1ed)
@

\subsubsection*{Two-edges-deleted subgraph complexity \cite{kim_wilhelm_2008}:}
\begin{equation}
C_{\mathit{2e,Spec}} := \frac{N_{\mathit{2e,Spec}} - 1}
  {\binom{m_{\mathit{cu}}}{2} - 1}
\end{equation}
where \(m_{\mathit{cu}}\) is defined like above and
\(N_{\mathit{2e,Spec}}\) is the number of two-edges-deleted subgraphs
which are different with regard to spectra of the Laplacian and signless
Laplacian matrix.
<<>>=
twoEdgesDeletedSubgraphComplexity(g)
twoEdgesDeletedSubgraphComplexity(g, sg.2ed)
@

\subsection{Product measures}

\subsubsection*{Medium articulation \cite{kim_wilhelm_2008}:}
\begin{equation}
\mathit{MAg} := \mathit{MA}_R \cdot \mathit{MA}_I
\end{equation}
with the redundancy
\begin{eqnarray}
\mathit{MA}_R &:=&
  4 \left( \frac{R - R_{\mathrm{path}}}{R_{\mathrm{clique}} - R_{\mathrm{path}}} \right)
  \left( 1 - \frac{R - R_{\mathrm{path}}}{R_{\mathrm{clique}} - R_{\mathrm{path}}} \right) \\
R &:=& \frac{1}{m} \sum_{i,j>i} \log(d_i d_j) \\
R_{\mathrm{clique}} &=& 2 \log(|N|-1) \\
R_{\mathrm{path}} &=& 2 \frac{|N|-2}{|N|-1} \log 2
\end{eqnarray}
and the mutual information
\begin{eqnarray}
\mathit{MA}_I &:=&
  4 \left( \frac{I - I_{\mathrm{clique}}}{I_{\mathrm{path}} - I_{\mathrm{clique}}} \right)
  \left( 1 - \frac{I - I_{\mathrm{clique}}}{I_{\mathrm{path}} - I_{\mathrm{clique}}} \right) \\
I &:=& \frac{1}{m} \sum_{i,j>i} \log \left(\frac{2m}{d_i d_j}\right) \\
I_{\mathrm{clique}} &=& \log \frac{|N|}{|N|-1} \\
I_{\mathrm{path}} &=& \log(|N|-1) - \frac{|N|-3}{|N|-1} \log 2
\end{eqnarray}
<<>>=
mediumArticulation(g)
@

\subsubsection*{Efficiency complexity \cite{kim_wilhelm_2008}:}
\begin{eqnarray}
\mathrm{Ce} &:=&
  4 \left(\frac{E - E_{\mathrm{path}}}{1 - E_{\mathrm{path}}}\right)
  \left(1 - \frac{E - E_{\mathrm{path}}}{1 - E_{\mathrm{path}}}\right) \\
E &:=& \frac{2}{|N| (|N|-1)} \sum_i \sum_{j>i} \frac{1}{d_{ij}} \\
E_{\mathrm{path}} &=& \frac{2}{|N| (|N|-1)} \sum_{i=1}{|N|-1} \frac{|N| - i}{i}
\end{eqnarray}
<<>>=
efficiency(g)
efficiency(g, mat.dist)
@

\subsubsection*{Graph index complexity \cite{kim_wilhelm_2008}:}
\begin{equation}
\mathit{Cr} = 4 c_r (1 - c_r)
\end{equation}
where \(c_r = \frac{r - 2 \cos \frac{\pi}{|N| + 1}}{|N| - 1 - 2 \cos
\frac{\pi}{|N| + 1}}\) and \(r\) is the largest eigenvalue of the
adjacency matrix of the graph.
<<>>=
graphIndexComplexity(g)
@

\section{Session Info}
<<>>=
sessionInfo()
@ 
\bibliographystyle{IEEEtran}
\bibliography{QuACN}

\end{document}

