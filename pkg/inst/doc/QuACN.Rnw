%\VignetteIndexEntry{QuACN}
\documentclass[a4paper]{article}
\usepackage{hyperref} 
\usepackage[hmargin=.75in,vmargin=1in]{geometry}
\usepackage[american]{babel}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{caption}
\usepackage{textcomp}
\usepackage{epsfig,graphicx}
\usepackage{xcolor}
\usepackage{amsfonts,amsmath,amssymb}
\usepackage{fixltx2e} % Fixing numbering problem when using figure/table* 
\usepackage{booktabs}

\title{\texttt{\textbf{QuACN}}: \textbf{Qu}antitative \textbf{A}nalyze of \textbf{C}omplex \textbf{N}etworks}
\author{Laurin AJ Mueller, Michael Schutte, Karl G Kugler, Matthias Dehmer\footnote{Corresponding author.}}
\begin{document}


\maketitle

  \begin{figure}[h]
  \hspace{-1cm}
  \centering
  \includegraphics[width=4cm]{logo.jpg}
  \hspace{-1cm}
  \end{figure}

\tableofcontents
\newpage
\section{Overview}
For information about the actual build see the projects website:

\begin{itemize}
 \item R-Forge: \url{http://quacn.r-forge.r-project.org/}
 \item CRAN: \url{http://cran.r-project.org/web/packages/QuACN/}
\end{itemize}

This vignette provides an overview about the usage of \texttt{QuACN}. 

Chapter \ref{sec:nw} will describe how to import already exiting networks. In Chapter \ref{sec:desc} a brief description of the implemented measures is presented, and it demonstrates how to call the related method in R.

\subsection{Installation}
\texttt{QuACN} uses the packages \texttt{graph} and \texttt{RBGL} from the \textit{Bioconductor} project. Before installing \texttt{QuACN}, \textit{Bioconductor} with the corresponding packages needs to be installed. For instructions see the \textit{Bioconductor} website:

\begin{itemize}
 \item Bioconductor: \url{http://www.bioconductor.org/}
\end{itemize}

Note, that \texttt{QuACN} also depends on the \texttt{Rmpfr} package. Therefore, the software GMP (\url{http://gmplib.org/}) and MPFR ( \url{http://www.mpfr.org/}) needs to be installed to install the package correctly:

\begin{itemize}
 \item Windows: The package should install without problems.
 \item Ubuntu/Debian: Make sure that the libraries \textit{libgmp3-dev} and \textit{libmpfr-dev} are installed.
\end{itemize}
For more information see the corresponding websites, or the documentation of the \texttt{Rmpfr} package (\url{http://rmpfr.r-forge.r-project.org/}).

After installing \textit{GMP} and \textit{MPFR} everything is ready to install \texttt{QuACN}. Other dependencies will be installed automatically during the installation. To install the package from \textit{CRAN} simply type: 

<<echo=TRUE, eval=FALSE>>=
install.packages("QuACN")
@
\section{Networks}
\label{sec:nw}
This section shows how to create networks in R to use them with \texttt{QuACN}.

\subsection{graphNEL}
<<echo=FALSE>>=
library("graph")
library("RBGL")
@ 
We generate a random graph with 8 nodes.  This graph will be used to explain the implemented methods. To analyze a network the network has to be represented by a \textit{graphNEL}-object, which is part of the Bioconductor \texttt{graph} package.\\

<<label=randGraph,include=FALSE>>=
library("QuACN")
set.seed(666)
g <- randomGraph(1:8, 1:5, 0.36)
g
@ 

\subsection{Adjacency Matrix}
<<echo=FALSE>>=
A <- adjacencyMatrix(g)
@ 

To create a \textit{graphNEL} object from an adjacency matrix $A$, just type following command:

<<label=randGraph,include=FALSE>>=
A
g <- as(A, "graphNEL")
g
@

Some descriptors, which are specially marked throughout this document, require vertex and/or edge weights.  Known attributes are:

\begin{itemize}
\item \texttt{"atom"}: Atomic number (such as \texttt{8}) or chemical symbol (such as \texttt{"O"}) of a graph vertex.
\item \texttt{"bond"}: Conventional bond order of an edge, i.e. 1 for single bonds, 2 for double bonds, 3 for triple bonds and 1.5 for aromatic bonds.
\end{itemize}

These can be set as follows:

<<>>=
nodeDataDefaults(g, "atom") <- "C"
nodeData(g, "6", "atom") <- "O"
edgeDataDefaults(g, "bond") <- 1
edgeData(g, "2", "3", "bond") <- 2
@

If existing networks are to be analyzed with \texttt{QuACN}, R offers several ways to import them. (It is important that the networks are represented by \textit{graphNEL}-objects.) Note that there is no general procedure to get networks into an R workspace. Some possibilities to import network data are listed below:

\begin{itemize}
\item \textbf{Adjacency matrix}: A representation of a network as an adjacency matrix can be easily imported and converted into a \textit{graphNEL} object.
\item \textbf{Node- and Edge-List}: With a list of nodes and Edges it is easy to create a \textit{graphNEL}-object.
\item \textbf{read.graph()}: The \texttt{read.graph()} method of the \textit{graph}-package offers the possibility to import graphs that a represented in different formats. For details see the manual of the \textit{graph}-package.
\item \textbf{System Biology Markup Language(SBML) \cite{Hucka2003}}: With the \textit{RSBML}-package it is possible to import SBML-Models.
\item \textbf{igrah-package}: Networks created with the \textit{igraph}-package can be converted into graphNEL objects.
\end{itemize}

\subsection{Extract the Largest Connected Subgraph}
Many of the topological network descriptors that are implemented in \texttt{QuACN} only work on connected graphs. Often this is not the case with biological networks, so that the largest connected component (LCC) has to be extracted first. For extracting the LCC we provide the method \texttt{getLargestSubgraph(g)}, as shown in \cite{Hahne2008}:
<<>>=
g2 <- randomGraph(paste("A", 1:100, sep=""), 1:4, p=0.03)
lcc <- getLargestSubgraph(g2)
lcc
@

\subsection{Enumerate Edge-Deleted Subgraphs}

Some descriptors require a list of all distinct subgraphs which can be
generated from a graph by removing one or two edges. The
concerning methods obtain this information automatically, but for
efficiency reasons, the user might want to pre-calculate and reuse it:

<<>>=
sg.1ed <- edgeDeletedSubgraphs(g)
sg.2ed <- edgeDeletedSubgraphs(sg.1ed)
@

Note that the method \texttt{edgeDeletedSubgraphs(g)} accepts lists or
single instances of graphNEL objects or adjacency matrices, but it
always returns a list of adjacency matrices.

\section{Network Descriptors}
\label{sec:desc}
This section provides a overview of the network descriptors that are included in the \texttt{QuACN} package. Here we describe the respective descriptor and how to call it in R.\\

Many descriptors have at least two parameters, the \textit{graphNEL}-object and the distance matrix representing the network. It is not necessary to pass the distance matrix to a function. If the parameters stays empty or is set to \textit{NULL} the distance matrix will be estimated within each function. But if the user wants to calculate more than one descriptor, it is recommended to calculate the distance matrix separately and pass it to each method. Some of the methods need the degree of each node or the adjacency matrix to calculate their results. If they were calculated once they should have kept for later use. For large networks in particular, it saves a lot of time to not calculate these parameters for each descriptor again, and will enhance the performance of the program to be developed.
<<>>=
mat.adj <- adjacencyMatrix(g)
mat.dist <- distanceMatrix(g)
vec.degree <- graph::degree(g)
ska.dia <- diameter(g)
ska.dia <- diameter(g, mat.dist)
@ 

In the definitions below, let \(G = \left(N(G), E(G)\right)\) be a finite and
connected graph.  \(N(G)\) and \(E(G)\) are called vertex and edge set of \(G\),
respectively.  As \(\left| N(G) \right| < \inf\), we can define \(\left| N(G)
\right| := N\).

\subsection{Descriptors Based on Distances in a Graph} \label{sec:dist}
This section describes network measures based on distances in the network.
\subsubsection*{ Wiener Index \cite{Wiener1947}:}
\begin{equation}
W(G):= \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}d(v_i,v_j).
\end{equation}
$d(v_i,v_j)$ stands for shortest distances between $v_i,v_j \in N(G)$.

<<>>=
wien <- wiener(g)
wiener(g, mat.dist)
@ 

\subsubsection*{Hararay Index \cite{balaban_ivanciuc_2000}:}
\begin{equation}
H(G):= \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}(d(v_i,v_j))^{-1}, \quad i \ne j.
\end{equation}
<<>>=
harary(g)
harary(g, mat.dist)
@ 
\subsubsection*{Balaban J Index \cite{balaban_1982}:}
\begin{equation}
J(G):= \frac{|E|}{\mu + 1} \sum_{(v_i,v_j) \in E} [DS{_i}DS{_j}]^{- \frac{1}{2}},
\end{equation}
<<>>=
balabanJ(g)
balabanJ(g, mat.dist)
@ 
where $|E(G)|:= |E|$ denotes the number of edges of the complex network, $DS_i$ denotes the distance sum (row sum) of $v_i$ and $\mu := |E| + 1 - N$ denotes the cyclomatic number.

\subsubsection*{Mean Distance Deviation \cite{skorobogatov}:}

See subsection \ref{dobr}.
% \begin{equation}
% \Delta\mu(G):= \frac{1}{N}\sum_{i=1}^{N}|\mu(v_i)- \bar{\mu}|,
% \end{equation}
% %
% where
% %
% \begin{equation}\label{dobrynin_eq1}
% \mu(v_i):= \sum_{j=1}^{N}d(v_i,v_j),
% \end{equation}
% %
% and
% \begin{equation}\label{dobrynin_eq2}
% \bar{\mu}:= \frac{2W}{N}.
% \end{equation}
% <<>>=
% meanDistanceDeviation(g)
% meanDistanceDeviation(g,mat.dist)
% @ 

\subsubsection*{Compactness  \cite{doyle_1977}:}
\begin{equation}
C(G):= \frac{4W}{N(N-1)}.
\end{equation}
<<>>=
compactness(g)
compactness(g, mat.dist)
compactness(g, mat.dist, wiener(g, mat.dist))
@ 
\subsubsection*{Product of Row Sums Index \cite{schultz_1992}:}
\begin{equation}
\text{PRS}(G)= \prod_{i=1}^{N} \mu(v_i) \quad \mbox{or} \quad   \log \big(\text{PRS}(G)\big)= \log\left( \prod_{i=1}^{N} \mu(v_i) \right).
\end{equation}


<<>>=
productOfRowSums(g, log=FALSE)
productOfRowSums(g, log=TRUE)
productOfRowSums(g, mat.dist, log=FALSE)
productOfRowSums(g, mat.dist, log=TRUE)
@ 
\subsubsection*{Hyper-distance-path Index \cite{todeschini_2002}}
\begin{equation}
D_P(G):= \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} d(v_i,v_j) +  \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}  {d(v_i,v_j) \choose 2}.
\end{equation}

<<>>=
hyperDistancePathIndex(g)
hyperDistancePathIndex(g, mat.dist)
hyperDistancePathIndex(g, mat.dist, wiener(g, mat.dist))
@ 

\subsubsection*{Skorobogatov and Dobrynin \cite{skorobogatov}:}\label{dobr}
This method calculates several descriptors:

\begin{enumerate}
\item Vertex Eccentricity \cite{skorobogatov}:
\begin{equation}
e(v) := max_{u \in N(G)} d(u,v)
\end{equation}

<<>>=
dob <- dobrynin(g)
dob <- dobrynin(g, mat.dist)
dob$eccentricityVertex
@


\item Eccentricity of a graph \cite{skorobogatov}:
\begin{equation}
e(G) := \sum_{v \in N(G)} e(v)
\end{equation}

<<>>=
dob$eccentricityGraph
@


\item Average Vertex Eccentricity of a Graph \cite{skorobogatov}:
\begin{equation}
e_{av}(G) := \frac{e(G)}{N}
\end{equation}

<<>>=
dob$avgeccOfG
@


\item Vertex Eccentric \cite{skorobogatov}:
\begin{equation}
\Delta e(v) := |e(v) - e_{av}(G)|
\end{equation}

<<>>=
dob$ecentricVertex
@


\item Eccentric of a Graph \cite{skorobogatov}:
\begin{equation}
\Delta G := \frac{1}{N} \sum_{v \in N(G)} \Delta e(v)
\end{equation}

<<>>=
dob$ecentricGraph
@


\item Vertex Centrality \cite{skorobogatov}:
\begin{equation}
D(v) := \sum_{v \in N(G)} d(v,u)
\end{equation}

<<>>=
dob$vertexCentrality
@


\item Graph Integration \cite{skorobogatov}:
\begin{equation}
D(G) := \frac{1}{2} \sum_{v \in N(G)} D(v)
\end{equation}

<<>>=
dob$graphIntegration
@


\item Unipolarity \cite{skorobogatov}:
\begin{equation}
D^*(G) := min_{u \in N(G)} D(v)
\end{equation}

<<>>=
dob$unipolarity
@


\item Distance Vertex Deviation \cite{skorobogatov}:
\begin{equation}
\Delta D^*(v) := D(v) - D^*(G)
\end{equation}

<<>>=
dob$vertexDeviation
@


\item Variation of a Graph \cite{skorobogatov}:
\begin{equation}
var(g) := max_{u \in N(G)} \Delta D^*(v) 
\end{equation}

<<>>=
dob$variation
@


\item Centralization \cite{skorobogatov}:
\begin{equation}
\Delta G^* := \sum_{v \in N(G)} \Delta D^*(v) 
\end{equation}

<<>>=
dob$centralization
@


\item Average Distance of Graph Vertices \cite{skorobogatov}:
\begin{equation}
D_{av}(g) := \frac{2 D(g)}{N}
\end{equation}

<<>>=
dob$avgDistance
@


\item Distance Vertex Deviation \cite{skorobogatov}:
\begin{equation}
\Delta D(v) := |D(v) - D_{av}(G)|
\end{equation}

<<>>=
dob$distVertexDeviation
@


\item Mean Distance Deviation \cite{skorobogatov}:
\begin{equation}
\Delta D(G):=\frac{1}{N} \sum_{v \in N(G)} \Delta D(v)
\end{equation}

<<>>=
dob$meanDistVertexDeviation
@


\end{enumerate}


\subsection{Descriptors Based on Other Graph-Invariants}
\label{sec:otherInv}
This section describes network measures based on other invariants than distances.


\subsubsection*{Index of Total Adjacency \cite{bonchev_book_2005}:}
\begin{equation}
A(G):= \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}a_{ij}.
\end{equation}
<<>>=
totalAdjacency(g)
totalAdjacency(g, mat.adj)
@ 

\subsubsection*{Zagreb Group Indices \cite{diudea, nikolic_2003}:}
\begin{equation}
Z_1(G):= \sum_{i=1}^{N} k_{v_i},
\end{equation}
where $k_{v_i}$ is the degree of the node $v_i$.
\begin{equation}
Z_2(G):= \sum_{(v_i,v_j) \in E} k_{v_i} k_{v_j}.
\end{equation}
Modified, augmented and variable Zagreb indices:
\begin{eqnarray}
\mathit{MZI(G)} &:=& \sum_{(v_i, v_j) \in E} \frac{1}{k_{v_i} k_{v_j}}, \\
\mathit{AZI(G)} &:=& \sum_{(v_i, v_j) \in E} \left( \frac{k_{v_i} k_{v_j}}{k_{v_i} + k_{v_j} - 2} \right)^3, \\
\mathit{VZI(G)} &:=& \sum_{(v_i, v_j) \in E} \frac{k_{v_i} + k_{v_j} - 2}{k_{v_i} k_{v_j}}.
\end{eqnarray}
<<>>=
zagreb1(g)
zagreb1(g, vec.degree)
zagreb2(g)
zagreb2(g, vec.degree)
modifiedZagreb(g)
modifiedZagreb(g, vec.degree)
augmentedZagreb(g)
augmentedZagreb(g, vec.degree)
variableZagreb(g)
variableZagreb(g, vec.degree)
@ 

\subsubsection*{Randi\'{c} Connectivity Index \cite{li_gutman_2006}:}
\begin{equation}
R(G):= \sum_{(v_i,v_j) \in E} [k_{v_i} k_{v_j}]^{- \frac{1}{2}}.
\end{equation}
<<>>=
randic(g)
randic(g, vec.degree)
@ 

\subsubsection*{The Complexity Index B \cite{bonchev_book_2005}:}
\begin{equation}
B(G):= \sum_{i=1}^{N} \frac{k_{v_i}}{\mu(v_i)}.
\end{equation}
  

<<>>=
complexityIndexB(g)
complexityIndexB(g, mat.dist)
complexityIndexB(g, mat.dist, vec.degree)
@ 
\subsubsection*{Normalized Edge Complexity \cite{bonchev_book_2005}:}
\begin{equation}
E_N(G):=\frac{A(G)}{N^2}.
\end{equation}
<<>>=
normalizedEdgeComplexity(g)
normalizedEdgeComplexity(g, totalAdjacency(g, mat.adj))
@ 

\subsubsection*{Atom-bond Connectivity \cite{estrada_1998}:}
\begin{equation}
\mathit{ABC(G)} := \sum_{(v_i, v_j) \in E} \sqrt{\frac{k_{v_i} + k_{v_j} - 2}{k_{v_i} k_{v_j}}}
\end{equation}
<<>>=
atomBondConnectivity(g)
atomBondConnectivity(g, vec.degree)
@

\subsubsection*{Geometric-arithmetic Indices \cite{zhou_2009}:}
\begin{eqnarray}
\mathit{GA1(G)} &:=& \sum_{(v_i, v_j) \in E} \frac{\sqrt{k_{v_i} k_{v_j}}}{\frac{1}{2} (k_{v_i} + k_{v_j})} \\
\mathit{GA2(G)} &:=& \sum_{(v_i, v_j) \in E} \frac{\sqrt{n_i n_j}}{\frac{1}{2} (n_i + n_j)} \\
\mathit{GA3(G)} &:=& \sum_{(v_i, v_j) \in E} \frac{\sqrt{m_i m_j}}{\frac{1}{2} (m_i + m_j)}
\end{eqnarray}
where
\begin{eqnarray}
n_i &:=& |\{x \in N(G) : d(x, v_i) < d(x, v_j)\}|, \\
n_j &:=& |\{x \in N(G) : d(x, v_j) < d(x, v_i)\}|, \\
m_i &:=& |\{f \in E : d(f, v_i) < d(f, v_j)\}|, \\
m_j &:=& |\{f \in E : d(f, v_j) < d(f, v_i)\}|.
\end{eqnarray}
In this context, the distance between an edge \(f = \{x, y\}\) and a vertex
\(v\) is defined as \(d(f, v) := \min \{d(x, v), d(y, v)\}\).
<<>>=
geometricArithmetic1(g)
geometricArithmetic1(g, vec.degree)
geometricArithmetic2(g)
geometricArithmetic2(g, mat.dist)
geometricArithmetic3(g)
geometricArithmetic3(g, mat.dist)
@

\subsubsection*{Narumi-Katayama Index \cite{narumi_katayama_1984}:}
\begin{equation}
\mathit{NK} := \prod_{i=1}^N k_{v_i}
\end{equation}
<<>>=
narumiKatayama(g)
narumiKatayama(g, vec.degree)
@

\subsection{Classical Entropy-based Descriptors}
\label{sec:clE}
These measures are based on grouping the elements of an arbitrary graph invariant (vertices, edges, and distances etc.) using an equivalence criterion.


\subsubsection*{Topological Information Content \cite{mowshowitz_1,rashewsky}:}
\begin{equation}\label{eq_mean_information_trucco}
I^V_{orb}(G) := -  \sum_{i=1}^{k} \frac{|N^V_i|}{N} \log \left( \frac{|N^V_i|}{N} \right).
\end{equation}
%
$|N^V_i|$ denotes the number of vertices belonging to the $i$-th vertex orbit.
<<>>=
topologicalInfoContent(g)
topologicalInfoContent(g, mat.dist)
topologicalInfoContent(g, mat.dist, vec.degree)
@ 

\subsubsection*{Bonchev - Trinajsti\'{c} Indices \cite{bonchev_Trinajstic_1977}:}
\begin{equation}
I_D(G) := - \frac{1}{N}\log\left( \frac{1}{N} \right)- \sum_{i=1}^{\rho(G)} \frac{2k_i}{N^2}\log\left( \frac{2k_i}{N^2} \right), \label{eq_mean_information_bonchev}
\end{equation}
\begin{equation}
I^W_D(G) := W(G) \log(W(G)) -  \sum_{i=1}^{\rho(G)} i k_i \log(i).
\end{equation}
%
\(\rho(G)\) is the diameter of the graph (the maximum distance between two nodes). $k_i$ is the occurrence of a distance possessing value $i$ in the distance matrix of $G$.
<<keep.source=TRUE>>=
#I_D(G)
bonchev1(g)
bonchev1(g, mat.dist)
#I^W_D(G)
bonchev2(g)
bonchev2(g, mat.dist)
bonchev2(g, mat.dist, wiener(g))
@
\subsubsection*{Bertz Complexity Index \cite{bertz_1981}:}
\begin{equation}\label{eq_total_information_bertz}
C(G):= 2N \log(N) - \sum_{i=1}^{k} |N_i| \log \left( |N_i| \right).
\end{equation}
%
$|N_i|$ are the cardinalities of the vertex orbits as defined in Eqn.~(\ref{eq_mean_information_trucco}).

<<>>=
bertz(g)
bertz(g, mat.dist)
bertz(g, mat.dist, vec.degree)
@ 
\subsubsection*{Radial Centric Information Index \cite{bonchev_2}:}
\begin{equation}\label{radial_index}
I_{C,R}(G) := \sum_{i=1}^{k} \frac{|N^e_i|}{N} \log \left( \frac{|N^e_i|}{N} \right).
\end{equation}
%
$|N^e_i|$ is the number of vertices having the same eccentricity.
<<>>=
radialCentric(g)
radialCentric(g, mat.dist)
@ 
\subsubsection*{Vertex Degree Equality-based Information Index \cite{bonchev_2}:}
\begin{equation}
I_{deg}(G) := \sum_{i=1}^{\bar{k}} \frac{|N^{k_v}_i|}{N} \log \left( \frac{|N^{k_v}_i|}{N} \right).
\end{equation}
%
$|N^{k_v}_i|$ is the number of vertices with degree equal to $i$ and $\bar{k}:= \max_{v\in N(G)}k_v$.
<<>>=
vertexDegree(g)
vertexDegree(g, vec.degree)
@ 
\subsubsection*{Balaban-like Information Indices \cite{balaban_1991}:}

Note that this class of Descriptors return \textit{Inf} for graphs with $N < 3$.

\begin{eqnarray}
U(G):= \frac{|E|}{\mu +1} \sum_{(v_i,v_j) \in E} [u(v_i)u(v_j)]^{- \frac{1}{2}}, \label{eq_balaban_U_index} \\
X(G):= \frac{|E|}{\mu +1} \sum_{(v_i,v_j) \in E} [x(v_i)x(v_j)]^{- \frac{1}{2}}, \label{eq_balaban_X_index}
\end{eqnarray}
%
where
%
\begin{eqnarray}
u(v_i) &:=&  -  \sum_{j=1}^{\sigma(v_i) } \frac{j|S_j(v_i,G)|}{\mu(v_i)} \log\left( \frac{j}{\mu(v_i)} \right), \\
x(v_i) &:=& - \mu(v_i) \log(d(v_i)) - y_i, \\
y_i &:=& \sum_{j=1}^{\sigma(v_i) } j|S_j(v_i,G)| \log(j),\\
\mu(v_i) &:=& \sum_{j=1}^{N}d(v_i,v_j) = \sum_{j=1}^{N} j|S_j(v_i,G)|.
\end{eqnarray}

<<keep.source=TRUE>>=
#Balaban-like information index U(G)
balabanlike1(g)
balabanlike1(g, mat.dist)
#Balaban-like information index X(G)
balabanlike2(g)
balabanlike2(g, mat.dist)
@

\subsubsection*{Graph Vertex Complexity Index \cite{raychaudhury_1984}:}
\begin{equation}
I_V(G):= \sum_{i=1}^{N}v^c_i,
\end{equation}
where $v^c_i$ is the so-called vertex complexity expressed by
\begin{equation}
v^c_i:= \sum_{j=0}^{\sigma(v_i)} \frac{k^{v_i}_j}{N} \log \left( \frac{k^{v_i}_j}{N} \right).
\end{equation}
$k^{v_i}_k$ is the number of distances starting from $V_i \in N(G)$ equal to $j$.
<<>>=
graphVertexComplexity(g)
graphVertexComplexity(g, mat.dist)
@ 

% TODO citations
\subsubsection*{Information Bond Index \cite{dosmorov}:}
\begin{equation}
I_B := |E| \cdot \log_2 |E| - \sum_m |E_m| \cdot \log_2 |E_m|,
\end{equation}
where \(E_m\) is the subset of \(E\) of edges with a multiplicity of \(m\).  The sum runs over all the different edge multiplicities in the graph.

This descriptor expects the conventional bond order in the \texttt{"bond"} edge data attribute of the input graph.

<<>>=
informationBondIndex(g)
@

\subsubsection*{Mean Information Content on the Edge Equality \cite{bonchev_1981}:}
\begin{equation}
^E\overline{I}^E_\chi = -\sum_g \frac{|E_g|}{|E|} \cdot \log_2 \frac{|E_g|}{|E|},
\end{equation}
where \(E_g\) is the subset of \(E\) of edges with an edge connectivity of \(g\).  The sum runs over all the different connectivity values of the edges in the graph.

<<>>=
edgeEqualityMIC(g)
edgeEqualityMIC(g, vec.degree)
@

\subsubsection*{Mean Information Content on the Edge magnitude \cite{bonchev_1981}:}
\begin{equation}
^E\overline{I}^M_\chi = -\sum_{(i, j) \in E}
  \frac{(k_i k_j)^{-1/2}}{R(G)} \cdot
  \log_2 \frac{(k_i k_j)^{-1/2}}{R(G)},
\end{equation}
where \(R(G)\) is the Randi\'{c} connectivity index and \(k_i\) are the vertex degrees.

<<>>=
edgeMagnitudeMIC(g)
edgeMagnitudeMIC(g, vec.degree)
@

\subsubsection*{Symmetry Index \cite{mowshowitz_dehmer_2010}:}
\begin{equation}
S(G) := \frac{1}{N} \sum_{i=1}^h |A_i| \log |A_i| + \log |\mathrm{Aut}(G)|,
\end{equation}
where \(\mathrm{Aut}(G)\) is the automorphism group with \(h\) orbits \(A_i\), \(1 \le i \le h\).

<<>>=
symmetryIndex(g)
@

\subsection{More Recent Graph Complexity Measures}

\subsubsection*{Medium Articulation \cite{kim_wilhelm_2008}:}
\begin{equation}
\mathit{MAg}(G) := \mathit{MA}_R(G) \cdot \mathit{MA}_I(G)
\end{equation}
with the redundancy
\begin{eqnarray}
\mathit{MA}_R(G) &:=&
  4 \left( \frac{R(G) - R_{\mathrm{path}}(G)} {R_{\mathrm{clique}}(G) - R_{\mathrm{path}}(G)} \right)
  \left( 1 - \frac{R(G) - R_{\mathrm{path}}(G)}{R_{\mathrm{clique}}(G) - R_{\mathrm{path}}(G)} \right) \\
R(G) &:=& \frac{1}{|E|} \sum_{i,j>i} \log(d_i d_j) \\
R_{\mathrm{clique}}(G) &=& 2 \log(N-1) \\
R_{\mathrm{path}}(G) &=& 2 \frac{N-2}{N-1} \log 2
\end{eqnarray}
and the mutual information
\begin{eqnarray}
\mathit{MA}_I(G) &:=&
  4 \left( \frac{I(G) - I_{\mathrm{clique}}(G)}{I_{\mathrm{path}}(G) - I_{\mathrm{clique}}(G)} \right)
  \left( 1 - \frac{I(G) - I_{\mathrm{clique}}(G)}{I_{\mathrm{path}}(G) - I_{\mathrm{clique}}(G)} \right) \\
I(G) &:=& \frac{1}{|E|} \sum_{i,j>i} \log \left(\frac{2 |E|}{d_i d_j}\right) \\
I_{\mathrm{clique}}(G) &=& \log \frac{N}{N-1} \\
I_{\mathrm{path}}(G) &=& \log(N-1) - \frac{N-3}{N-1} \log 2
\end{eqnarray}
<<>>=
mediumArticulation(g)
@

\subsubsection*{Efficiency Complexity \cite{kim_wilhelm_2008}:}
\begin{eqnarray}
\mathrm{Ce(G)} &:=&
  4 \left(\frac{E(G) - E_{\mathrm{path}}(G)}{1 - E_{\mathrm{path}}(G)}\right)
  \left(1 - \frac{E(G) - E_{\mathrm{path}}(G)}{1 - E_{\mathrm{path}}(G)}\right) \\
E(G) &:=& \frac{2}{N (N-1)} \sum_i \sum_{j>i} \frac{1}{d_{ij}} \\
E_{\mathrm{path}}(G) &=& \frac{2}{N (N-1)} \sum_{i=1}{N-1} \frac{N - i}{i}
\end{eqnarray}
<<>>=
efficiency(g)
efficiency(g, mat.dist)
@

\subsubsection*{Graph Index Complexity \cite{kim_wilhelm_2008}:}
\begin{equation}
\mathit{Cr}(G) := 4 c_r (1 - c_r)
\end{equation}
where \[
  c_r := \frac{r - 2 \cos \frac{\pi}{N + 1}}{N - 1 - 2 \cos \frac{\pi}{N + 1}}
\] and \(r\) is the largest eigenvalue of the adjacency matrix of the graph.
<<>>=
graphIndexComplexity(g)
@

\subsubsection*{Offdiagonal Complexity \cite{kim_wilhelm_2008}:}
\begin{equation}
\mathit{OdC(G)} := - \frac{1}{log(N-1)}
  \sum_{n=0}^{k_{\mathrm{max}}-1} \tilde{a}_n \log \tilde{a}_n,
\end{equation}
with
\begin{eqnarray}
  \tilde{a}_n &:=& \frac{a_n}{\sum_{m=0}^{k_{\mathrm{max}}-1} a_m}, \\
  a_n &:=& \sum_{i=1}^{k_{\mathrm{max}-N}} c_{i,i+N},
\end{eqnarray}
where \(k_{\mathrm{max}}\) is the maximum degree of all nodes in the graph, and
\(c_{ij}\) is the number of all neighbors with degree \(j \ge i\) of all nodes
with degree \(i\).
<<>>=
offdiagonal(g)
offdiagonal(g, vec.degree)
@

\subsubsection*{Spanning Tree Sensitivity \cite{kim_wilhelm_2008}:}
\begin{equation}
\mathit{STS(G)} := \frac{-\sum_l a_l \log a_l}{\log m_{\mathit{cu}}},
\end{equation}
with \(m_{\mathit{cu}} = N^{1.68}-10\),
\begin{eqnarray}
  a_l &:=& \frac{S_{ij}^l}{\sum_r^k S_{ij}^r}, \\
  S_{ij} &:=& s_{ij} - (\min\{s_{ij}\} - 1),
\end{eqnarray}
\(\{S_{ij}^1, S_{ij}^2, \ldots, S_{ij}^k\}\) being an ordered list of all \(k\)
different \(S_{ij}\).  \(s_{ij}\) is the number of spanning trees in the graph
minus the number of spanning trees of the subgraph with the edge \(\{v_i,
v_j\}\) deleted.  Analogously, the spanning tree sensitivity differences
measure is defined as
\begin{equation}
\mathit{STSD(G)} := \frac{-\sum_l b_l \log b_l}{\log m_{\mathit{cu}}},
\end{equation}
with \[
  b_l = \frac{\mathit{Ld}_l}{\sum_r^d \mathit{Ld}_r}
\], where \(\{\mathit{Ld}_1, \mathit{Ld}_2, \ldots, \mathit{Ld}_d\}\) is the
ordered list of all unique differences \(S_{ij}^m - S_{ij}^{m-1}\).
<<>>=
spanningTreeSensitivity(g)
spanningTreeSensitivity(g, sg.1ed)
@

\subsubsection*{Distance Degree/Code Centric Indices \cite{dehmer_match_dist}:}
\begin{eqnarray}
I_{\mathrm{C,deg}}(G) &:=& -\sum_{i=1}^D \frac{d_i}{N} \log_2 \frac{d_i}{N}, \\
I_{\mathrm{C,code}}(G) &:=& -\sum_{i=1}^C \frac{c_i}{N} \log_2 \frac{c_i}{N}.
\end{eqnarray}
where \(d_i\) is the number of vertices with the same eccentricity and
the same vertex distance degree (i.\,e., equal row sums in the distance
matrix), and \(c_i\) is the number of vertices with the same vertex
distance code (i.\,e., the same numbers in their rows in the distance
matrix).  \(D\) and \(C\) are the respective numbers of equivalence
classes.
<<>>=
distanceDegreeCentric(g)
distanceDegreeCentric(g, mat.dist)
distanceCodeCentric(g)
distanceCodeCentric(g, mat.dist)
@

\subsection{Parametric Graph Entropy Measures}
\label{sec:dE}
Measures of this group \cite{dehmer_functionals_2008,dehmer_varmuza_2009} assign a probability value to each vertex of the network using a so-called information functional $f$ which captures structural information of the network $G$.
\begin{equation}\label{eq:if}
I_{f}(G):=-\sum_{i=1}^{N}{\frac{f(v_i)}{\sum_{j=1}^{N}f(v_j)} \log\left(\frac{f(v_i)}{\sum_{j=1}^{N}f(v_j)}\right)},
\end{equation}
%
where $I_{f}(G)$ represents a family of graph entropy \cite{dehmer_functionals_2008} measures depending on the information functional.
Further we implemented the following measurement\cite{dehmer_varmuza_2009}:
\begin{equation}\label{eq:dist}
I^{\lambda}_{f}(G) := \lambda \left( \log(N) + \sum_{i=1}^{N}{p(v_i)\log(p(v_i))} \right),
\end{equation}
\begin{equation}\label{eq:pis}
p(v_i):={\frac{f(v_i)}{\sum_{j=1}^{N}f(v_j)}},
\end{equation}
where $p^V(v_i)$ are the vertex probabilities, and $\lambda > 0$ is a scaling constant. This measure can be interpreted as the distance between the entropy defined in equation \ref{eq:if} and maximum entropy ($\log(N)$).
We integrated 4 different information functionals \cite{dehmer_functionals_2008, dehmer_hindawi_2010}:

\begin{enumerate}
\item An information functional using the $j$-spheres (\textit{"sphere"}):
\begin{equation}
\label{eq:spherfunct}
f^{V}(v_i):= c_1|S_1(v_i,G)| + c_2|S_2(v_i,G)| + \cdots + c_{\rho(G)}|S_{\rho(G)}(v_i,G)|,
\end{equation}
where $ c_k > 0$.

\item An information functional using path lengths (\textit{"pathlength"}):
\begin{equation}
  f^{P}(v_i) := c_1l(P(L_G(v_i,1))) + c_2l(P(L_G(v_i,2))) + \cdots + c_{\rho(G)}l(P(L_G(v_i,\rho(G)))),
\end{equation}
where $ c_k > 0$.
\item An information functional using vertex centrality(\textit{"vertcent"}) :
\begin{equation} 
  f^{C}(v_i) := c_1\beta^{L_G(v_i,1)}(v_i) + c_2\beta^{L_G(v_i,2)}(v_i) + \cdots + c_{\rho(G)}\beta^{L_G(v_i,\rho(G))}(v_i),
\end{equation}
where $ c_k > 0$.
\item Calculates the degree-degree association index(\textit{"degree"}) \cite{dehmer_hindawi_2010}:
\begin{equation} 
  f^{\Delta}(v_i) := \alpha^{c_1 \Delta^G(v_i,1) + c_2 \Delta^G(v_i,2) + \cdots + c_{\rho(G)} \Delta^G(v_i,{\rho(G)})},
\end{equation}
where $ c_k > 0$, $1 \leq k \leq \rho(G)$ and $\alpha>0$. Note that \(f^{\Delta}\) is well-defined for \(\alpha > 0\).  Please consider that the results of the degree-degree association index are often very close to zero and can only be represented with a special data type (see the hint at the end of this section).
\end{enumerate}



We implemented 4 different settings (as example settings) for weighting the
parameters $c_i$ ($\rho(G)$ represents the diameter of the network):

\begin{enumerate}
\item constant
\begin{equation}
\label{eq:const}
c_1:= 1,\, c_2:=  1, \cdots, \, c_{\rho(G)}:= 1.
\end{equation}

\item linear
\begin{equation}
\label{eq:lin}
c_1:= \rho(G),\, c_2:= \rho(G)-1, \cdots, \, c_{\rho(G)}:= 1.
\end{equation}

\item quadratic
\begin{equation}
\label{eq:exp}
c_{1}:= \rho(G)^2, c_{2}:= (\rho(G)-1)^2, \cdots, c_{\rho(G)}:= 1.
\end{equation}

\item exponential
\begin{equation}
\label{eq:exp}
c_{1}:= \rho(G), c_{2}:= \rho(G)e^{1}, \cdots, c_{\rho(G)}:= \rho(G)e^{-\rho(G) + 1}.
\end{equation}

\end{enumerate}

To call this type of network measure we provide the method \textit{infoTheoreticGCM}. 
It has following input parameters:
\begin{itemize}
\item \textit{g}: the network as a graphNEL object - it is the only mandatory parameter
\item \textit{dist}: the distance matrix of g
\item \textup{coeff}: specifies the weighting parameter: "const", "lin", "quad", "exp", "const" or "cust" are available constants. If it is set to "cust", a customized weighting schema has to be specified through the \textit{custCoeff} parameter.
\item \textit{infofunct}: specifies the information functional: "sphere", "pathlength", "vertcent" or "degree" are available settings.
\item \textit{lambda}: scaling constant for the distance, default set to 1000.
\item \textit{custCoeff}: specifies the customized weighting schema. \textit{coeff} must be set to "const" in order to use it.
\item \textit{alpha}: alpha for degree degree association.
\item \textit{prec}: specifies the floating-point precision to use (currently only implemented for degree-degree association).  Values up to 53 are handled with the built-in double data type; larger values trigger the usage of Rmpfr.

\end{itemize}

Note that some combinations of these settings can cause the descriptor to return \textit{NaN}. In that case it is the user's responsibility to check for \textit{warnings}.  For \texttt{infofunct="degree"} in particular, also see the note below.

The method returns a list with following entries:
\begin{itemize}
\item \textit{entropy}: contains the entropy, see formula \ref{eq:if} 
\item \textit{distance}: contains the distance described in formula \ref{eq:dist}
\item \textit{pis}: contains the probability distribution, see formula \ref{eq:pis}
\item \textit{fvi}: contains the values of the used information functional for each vertex $v_i$
\end{itemize}

<<>>=
l1 <- infoTheoreticGCM(g)
l2 <- infoTheoreticGCM(g, mat.dist, coeff="lin", infofunct="sphere", lambda=1000)
l3 <- infoTheoreticGCM(g, mat.dist, coeff="const", infofunct="pathlength", lambda=4000)
l4 <- infoTheoreticGCM(g, mat.dist, coeff="quad", infofunct="vertcent", lambda=1000)
l5 <- infoTheoreticGCM(g, mat.dist, coeff="exp", infofunct="degree", lambda=1000)
l1
l5
@ 

\textbf{Important:} Note, the functional based on degree-degree associations (\texttt{infofunct="degree"}) can result in values that cannot be represented by standard data types. This problem manifests itself in \textit{NaN} as return values. Note, that this issue can be avoided by specifying a floating-point precision value greater than 53, using the parameter \textit{prec} (e.g. \texttt{prec=128} is usually enough).  In this case, the \texttt{Rmpfr} package will be used and the list, returned by the function will contain vectors of the class \textit{mpfr}. These vectors can be used as usual numeric vectors, except that all calculations will result in \textit{mpfr} vectors. Note, that \texttt{as.double} can be used to convert such a vector back to the regular \textit{numeric} vector once the result is in the representable range (between \(10^{-380}\) and \(10^{380}\)). The following example shows how to work with vectors of type \textit{mpfr}:

<<>>=
l5mpfr <- infoTheoreticGCM(g, mat.dist, coeff="exp", infofunct="degree", lambda=1000, prec=128)
l5mpfr$entropy
l5mpfr$entropy * 2^3
as.double(l5mpfr$entropy * 2^3)
@

For more details about \textit{mpfr} vectors, please consult the \texttt{Rmpfr} documentation.

\subsubsection*{Parametric Entropy Measures for Labeled Graphs \cite{dehmer_topo_labeled}:}
These three functionals are similar to the ones above, but additionally use vertex or edge labels in order to distinguish between different bond types and heteroatoms.  For practical reasons, they are not implemented as part of \textit{infoTheoreticGCM}.

\(f^{V_1}\) and \(f^{V_2}\) require the atomic number or chemical symbol in the \texttt{"atom"} vertex data attribute.  \(f^E\) needs the conventional bond order in the \texttt{"bond"} vertex attribute.

The functionals are defined as
\begin{eqnarray}
f^{V_1}(v_i) &:=& \sum_{k=1}^{\rho(G)} \sum_{\mu=1}^{|A_V^G|}
  c_k^{l_v^{\mu}} \left| S_k^{l_v^{\mu}}(v_i, G) \right|, \\
f^{V_2}(v_i) &:=& \sum_{\mu=1}^{|A_V^G|} \left( c_{l_v^{\mu}} \cdot
  \sum_{k=1}^{\rho(G)} \left| V_{l_v^{\mu}}(\mathcal{L}_G(v_i, k)) \right| \right), \\
f^E(v_i) &:=& \sum_{k=1}^{\rho(G)} c_k \cdot \omega(\mathcal{L}_G(v_i, k)).
\end{eqnarray}
\(S_j^{l_v^{\mu}}\) is the set of vertices on the \(j\)-sphere of \(v_i\) with the node label \(l_v^{\mu}\).  \(|A_V^G|\) is the number of distinct node labels.  \(\mathcal{L}_G(v_i, j)\) is called a local information graph regarding \(v_i\).  Its vertex set consists of the vertices on the \(j\)-sphere of \(v_i\) and all vertices along all the shortest paths from \(v_i\) to these vertices.  Its edge set contains all edges that make up these shortest paths.  \(\omega(\mathcal{L}_G(v_i, j))\) is defined as
\begin{eqnarray}
\omega(\mathcal{L}_G(v_i, j)) &:=& \sum_{\mu=1}^{k_j} \omega(P_{\mu}^j(v_i)), \\
\omega(P_{\mu}^j(v_i)) &:=& \omega(e_1^{\mu}) + \cdots + \omega(e_j^{\mu}),
\end{eqnarray}
\(k_j\) being the number of shortest paths of length \(j\) from \(v_i\), and \(\omega(e_i^{\mu})\) the conventional bond order of the \(i\)th edge along the path \(P_{\mu}^j\).

The \(c\) values are understood as follows:
\begin{itemize}
\item \(f^{V_1}(v_i)\): \(c_j^{l_v^{\mu}}\) is the weighting coefficient for vertices on the \(j\)-sphere of \(v_i\) whose label is \(l_v^{\mu}\).  It can be defined by passing as the \textit{coeffMatrix} parameter to \textit{infoTheoreticLabeledV1} a matrix whose columns represent the elements and whose rows the values of \(j\); the columns have to be named according to the chemical symbols.  The matrix chosen by default represents \(c_j^a = c_j - m_a / 238\), where \(m_a\) is the atomic mass of the atom \(a\).  Values for \(c_j\) can be selected using \textit{coeff} and \textit{custCoeff} as described above; the default is \texttt{"lin"}.
\item \(f^{V_2}(v_i)\): \(c_{l_v^{\mu}}\) is the weighting coefficient for vertices whose label is \(l_v^{\mu}\).  Different values can be chosen by passing a list in the \textit{ci} parameter to \textit{infoTheoreticLabeledV2} which maps chemical symbols to coefficients.  By default, all \(c_{l_v^{\mu}}\) are \(1\).
\item \(f^E(v_i)\): \(c_k\) is the weighting coefficient for paths of length \(k\).  The coefficient values can be set using the \textit{coeff}/\textit{custCoeff} mechanism described above; \texttt{"lin"} is selected by default.
\end{itemize}

For all functions, \textit{lambda} can be used to set a scaling constant different from the default \(1000\).

<<>>=
lv1 <- infoTheoreticLabeledV1(g, coeff="exp")
lv1$entropy
lv2 <- infoTheoreticLabeledV2(g, ci=list(`C` = 0.8, `O` = 1))
lv2$entropy
le <- infoTheoreticLabeledE(g, coeff="quad")
le$entropy
@

\cite{dehmer_topo_labeled} also defines functionals \(f^{V_1,E}\) and \(f^{V_2,E}\) as the sum of a vertex- and an edge-labeled-based functional.  Given the result of \textit{infoTheoreticLabeledE} and one of \textit{infoTheoreticLabeledV1} or \textit{infoTheoreticLabeledV2}, the \textit{infoTheoreticSum} method can be used to calculate these sums correctly.

<<>>=
lv1e <- infoTheoreticSum(lv1, le)
lv1e$entropy
lv2e <- infoTheoreticSum(lv2, le)
lv2e$entropy
@

\subsection{Eigenvalue-based Descriptors}

This class contains eigenvalue-based Descriptors proposed in Dehmer et. al \cite{dehmer_hindawi_2010}. 

\begin{equation}
H_{M_s}(G)=\sum_{i=1}^k \frac{|\lambda_i|^{\frac{1}{s}}}{\sum_{j=1}^k |\lambda_j|^{\frac{1}{s}}} \log \left( \frac{|\lambda_i|^{\frac{1}{s}}}{\sum_{j=1}^k |\lambda_j|^{\frac{1}{s}}} \right),
\end{equation}

\begin{equation}
S_{M_s}(G)= |\lambda_1|^{\frac{1}{s}} + |\lambda_2|^{\frac{1}{s}} + \ldots + |\lambda_k|^{\frac{1}{s}},
\end{equation}

\begin{equation}
IS_{M_s}(G)= \frac{1}{|\lambda_1|^{\frac{1}{s}} + |\lambda_2|^{\frac{1}{s}} + \ldots + |\lambda_k|^{\frac{1}{s}}},
\end{equation}

\begin{equation}
P_{M_s}(G)=|\lambda_1|^{\frac{1}{s}} \cdot |\lambda_2|^{\frac{1}{s}}  \ldots  |\lambda_k|^{\frac{1}{s}},
\end{equation}

\begin{equation}
IP_{M_s}(G)= \frac{1}{|\lambda_1|^{\frac{1}{s}} \cdot |\lambda_2|^{\frac{1}{s}}  \ldots  |\lambda_k|^{\frac{1}{s}}},
\end{equation}

Using this function, it is possible to calculate 5 descriptors ($H_{M_s(G)}$, $S_{M_s(G)}$ , $IS_{M_s(G)}$, $P_{M_s(G)}$, $IP_{M_s(G)}$) for 10 different matrices:

\begin{enumerate}
\item Adjacency matrix
<<>>=
eigenvalueBased(g, adjacencyMatrix,2)
@ 
\item Laplacian matrix
<<>>=
eigenvalueBased(g, laplaceMatrix,2)
@
\item Distance matrix
<<>>=
eigenvalueBased(g, distanceMatrix,2)
@
\item Distance path Matrix
<<>>=
eigenvalueBased(g,distancePathMatrix,2)
@
\item Augmented vertex degree matrix
<<>>=
eigenvalueBased(g, augmentedMatrix,2)
@
\item Extended adjacency matrix
<<>>=
eigenvalueBased(g, extendedAdjacencyMatrix,2)
@
\item Vertex Connectivity matrix 
<<>>=
eigenvalueBased(g, vertConnectMatrix,2) 
@
\item Random Walk Markov matrix 
<<>>=
eigenvalueBased(g, randomWalkMatrix,2)  
@
\item Weighted structure function matrix $IM_1$
<<>>=
eigenvalueBased(g, weightStrucFuncMatrix_lin,2) 
@
\item Weighted structure function matrix $IM_2$
<<>>=
eigenvalueBased(g, weightStrucFuncMatrix_exp,2)
@
\end{enumerate}

For a detailed description of this class see Dehmer et. al \cite{dehmer_hindawi_2010}.

\subsubsection*{Graph Energy and Laplacian Energy \cite{gutman_zhou_2006}:}
\begin{eqnarray}
E(G) &:=& \sum_{i=1}^{N} |\lambda_i| \\
\mathit{LE(G)} &:=& \sum_{i=1}^{N} \left| \mu_i - \frac{2 |E|}{N} \right|
\end{eqnarray}
where \(\lambda_k\) are the eigenvalues of the adjacency matrix and \(\mu_k\) those of the Laplacian matrix of the graph.
<<>>=
energy(g)
laplacianEnergy(g)
@

\subsubsection*{Estrada \cite{estrada_2000} and Laplacian Estrada \cite{fath-tabar_2009} Indices:}
\begin{eqnarray}
\mathit{EE(G)} &:=& \sum_{i=1}^{N} e^{\lambda_i} \\
\mathit{LEE(G)} &:=& \sum_{i=1}^{N} e^{\mu_i}
\end{eqnarray}
with \(\lambda_k\) and \(\mu_k\) defined as above.
<<>>=
estrada(g)
laplacianEstrada(g)
@

\subsubsection*{Spectral Radius:}
\begin{equation}
\mathit{SpRad(G)} := \max_i \left\{|\lambda_i|\right\}
\end{equation}
<<>>=
spectralRadius(g)
@

\subsection{Subgraph Measures}

\subsubsection*{One-edge-deleted Subgraph Complexity \cite{kim_wilhelm_2008}:}
\begin{eqnarray}
C_{\mathit{1e,ST}}(G) &:=& \frac{N_{\mathit{1e,ST}} - 1}{m_{\mathit{cu}}-1} \\
C_{\mathit{1e,Spec}}(G) &:=& \frac{N_{\mathit{1e,Spec}} - 1}{m_{\mathit{cu}} - 1}
\end{eqnarray}
\(N_{\mathit{1e,ST}}\) is the number of one-edge-deleted subgraphs which
are different with regard to the number of spanning trees.  Similarly,
\(N_{\mathit{1e,Spec}}\) is the number of one-edge-deleted subgraphs
which are different with regard to spectra of the Laplacian and signless
Laplacian matrix.  \(m_\mathit{cu}\) is defined as \(N^{1.68}-10\).
<<>>=
oneEdgeDeletedSubgraphComplexity(g)
oneEdgeDeletedSubgraphComplexity(g, sg.1ed)
@

\subsubsection*{Two-edges-deleted Subgraph Complexity \cite{kim_wilhelm_2008}:}
\begin{equation}
C_{\mathit{2e,Spec}}(G) := \frac{N_{\mathit{2e,Spec}} - 1}
  {\binom{m_{\mathit{cu}}}{2} - 1}
\end{equation}
where \(m_{\mathit{cu}}\) is defined like above and
\(N_{\mathit{2e,Spec}}\) is the number of two-edges-deleted subgraphs
which are different with regard to spectra of the Laplacian and signless
Laplacian matrix.
<<>>=
twoEdgesDeletedSubgraphComplexity(g)
twoEdgesDeletedSubgraphComplexity(g, sg.2ed)
@

\subsubsection*{Local Clustering Coefficient \cite{watts2003small, watts1998collective}:}
Let $G_{N(v)} = (V_{N(v)}, E_{N(v)})$ be the subgraph of $G$ that contains all neighborhood vertices and their edges. Then the local clustering coefficient of a graph $G$ is defined by
\begin{equation}
C_v(G):= \frac{E_{N(v)}}{\frac{V_{N(v)}*(V_{N(v)}-1)}{2}}.
\end{equation}

<<>>=
localClusteringCoeff(g)
localClusteringCoeff(g, deg=vec.degree)
@

\subsubsection*{Global Clustering Coefficient \cite{watts2003small, watts1998collective}:}
\begin{equation}
C(G):= \sum_{v \in N(g)} := \frac{1}{N} \cdot C_v
\end{equation}

<<>>=
loccc <- localClusteringCoeff(g)
globalClusteringCoeff(g)
globalClusteringCoeff(g, loc=loccc)
@

\subsection{ID numbers}

\subsubsection*{Randi\'{c} Connectivity ID Number \cite{randic1984molecular}:} 
\begin{equation}
\mathit{CID} := N + \sum_{^{m}p_{ij}} w_{ij},
\end{equation}
where \(^{m}p_{ij}\) are all paths of length \(m > 0\), and \(w_{ij}\) is a path weight defined as
\begin{equation}
w_{ij} = \prod_{b=1}^m \left( k_{b(1)} k_{b(2)} \right)_b^{-1/2},
\label{eq:cid-weight}
\end{equation}
with the sum running over all edges in the path and \(k_{b(1)}\), \(k_{b(2)}\) referring to the degrees of the two vertices incident to the \(b\)th edge.

<<>>=
connectivityID(g)
connectivityID(g, deg=vec.degree)
@

\subsubsection*{MINCID \cite{ivanciuc1996design}:}

\begin{equation}
\mathit{MINCID} := N + \sum_{^{\min}p_{ij}} w_{ij},
\end{equation}
where the sum runs over all shortest paths \(^{\min}p_{ij}\) between the vertices \(v_i\) and \(v_j\), and \(w_{ij}\) is taken from equation \ref{eq:cid-weight}.

<<>>=
minConnectivityID(g)
minConnectivityID(g, deg=vec.degree)
@

\subsubsection*{Prime ID Number \cite{randic1986molecular}:}

\begin{equation}
\mathit{PID} := N + \sum_{^{m}p_{ij}} w_{ij},
\end{equation}
with \(^{m}p_{ij}\) like above and the path weight \(w_{ij}\)
\begin{equation}
w_{ij} = \prod_{b=1}^m {pn}_b^{-1/2},
\end{equation}
where \({pn}_b\) is a prime number chosen according to the degrees of the vertices adjacent to the \(b\)th edge.

<<>>=
primeID(g)
primeID(g, deg=vec.degree)
@

\subsubsection*{Conventional Bond Order ID Number \cite{randic1989fragment}:}

\begin{equation}
\mathit{\pi ID} := N + \sum_{^mp_{ij}} w_{ij},
\end{equation}
with \(^{m}p_{ij}\) like above and the path weight \(w_{ij}\)
\begin{equation}
w_{ij} = \prod_{b=1}^m \pi^*_b,
\end{equation}
where \(\pi^*_b\) is the conventional bond order of the \(b\)th edge.

The conventional bond order must be set as the \texttt{"bond"} edge data attribute of the input graph.

<<>>=
bondOrderID(g)
@

\subsubsection*{Balaban ID Number \cite{balaban1987local}:}

\begin{equation}
\mathit{BID} := N + \sum_{^mp_{ij}} w_{ij},
\end{equation}
with \(^{m}p_{ij}\) like above and the path weight \(w_{ij}\)
\begin{equation}
w_{ij} = \prod_{b=1}^m \left( \sigma_{b(1)} \cdot \sigma_{b(2)} \right)_b^{-1/2},
\label{eq:bid-weight}
\end{equation}
where \(\sigma_k\) is the vertex distance degree and \(b(1), b(2)\) refer to the vertices adjacent to the edge \(b\).

<<>>=
balabanID(g)
balabanID(g, dist=mat.dist)
@

\subsubsection*{MINBID \cite{ivanciuc1996design}:}

\begin{equation}
\mathit{MINBID} := N + \sum_{^{\min}p_{ij}} w_{ij},
\end{equation}
where the sum runs over all shortest paths \(^{\min}p_{ij}\) between the vertices \(v_i\) and \(v_j\), and \(w_{ij}\) is taken from equation \ref{eq:bid-weight}.

<<>>=
minBalabanID(g)
minBalabanID(g, dist=mat.dist)
@

\subsubsection*{Weighted ID Number \cite{szymanski1986identification}:}

\begin{equation}
\mathit{WID} := N - \frac{1}{N} + \frac{\mathit{ID}^*}{N^2},
\end{equation}
with
\begin{eqnarray}
\mathit{ID}^* &:=& \sum_{i=1}^N \sum_{j=1}^N w^*_{ij}, \\
W^* &:=& \sum_{k=0}^{N-1} {^{\sigma}\chi^k},
\end{eqnarray}
where \(^{\sigma}\chi\) is the distance-sum-connectivity matrix.

<<>>=
weightedID(g)
@

\subsubsection*{Hu-Xu ID Number \cite{hu1994hall}:}

\begin{equation}
\mathit{HXID} := \sum_{i=1}^{N} \mathit{AID}_i^2
\end{equation}
with
\begin{eqnarray}
\mathit{AID}_i &:=& \sum_{j=1}^N w_{ij}, \\
w_{ij} &:=& \prod_{a=2}^{m+1}
  \left( \frac{\pi^*_{a-1,a}} \cdot \frac{1}{k'_{a-1} \cdot k'_a} \right)^{1/2}, \\
k'_a &:=& k_a \cdot \sqrt{Z_a},
\end{eqnarray}
where \(Z_a\) is the atomic number of \(v_a\) and \(k_a\) is the degree of the vertex \(v_a\).

The \texttt{huXuID} method requires the input graph to store the atomic numbers or chemical symbols in the \texttt{"atom"} vertex data attribute and the conventional bond order in the \texttt{"bond"} edge data attribute.

<<>>=
huXuID(g)
huXuID(g, deg=vec.degree)
@

\section{Calculating Multiple Descriptors at Once}

The \texttt{calculateDescriptors} function provides a simple interface
to calculate a set of descriptors on a list of input graphs.  The result
is returned as a data frame.  The desired functions can be specified by
name or by number.  It is also possible to name the columns according to
the names given in this document.

Please see the function documentation for a detailed description and a
full list of the supported descriptors together with their numbers.

<<>>=
calculateDescriptors(g, "wiener")
calculateDescriptors(g, 1001)
calculateDescriptors(g, 2000, labels=TRUE)
@

\section{Session Info}
<<>>=
sessionInfo()
@ 
\bibliographystyle{IEEEtran}
\bibliography{QuACN}

\end{document}

